
===============================================================================
PROJECT EXPORT
Generated: 12/07/2025 11:08:52
Project Path: C:\Users\kushal\source\repos\HelloDotnetTen
===============================================================================

DIRECTORY STRUCTURE:
===================

Folder PATH listing
Volume serial number is 9892-5BAD
C:\USERS\KUSHAL\SOURCE\REPOS\HELLODOTNETTEN
|   .gitignore
|   export.ps1
|   publish.ps1
|   
+---docs
|   \---llm
|           claude.txt
|           dump.txt
|           gemini.txt
|           output.txt
|           
\---source
    \---HelloDotnetTen
        |   Directory.Build.props
        |   Directory.Build.targets
        |   Directory.Packages.props
        |   HelloDotnetTen.slnx
        |   
        +---HelloDotnetTen.ClassLibrary1
        |   |   Class1.cs
        |   |   Class1Options.cs
        |   |   Class2.cs
        |   |   Class2Options.cs
        |   |   ClassLibrary1Settings.cs
        |   |   HelloDotnetTen.ClassLibrary1.csproj
        |   |   IClass1.cs
        |   |   IClass2.cs
        |   |   ServiceCollectionExtensions.cs
        |   |   
        |   +---bin
        |   |   \---Debug
        |   |       \---net10.0
        |   \---obj
        |       \---Debug
        |           \---net10.0
        |                   .NETCoreApp,Version=v10.0.AssemblyAttributes.cs
        |                   HelloDotnetTen.ClassLibrary1.AssemblyInfo.cs
        |                   HelloDotnetTen.ClassLibrary1.AssemblyInfoInputs.cache
        |                   HelloDotnetTen.ClassLibrary1.csproj.AssemblyReference.cache
        |                   HelloDotnetTen.ClassLibrary1.GeneratedMSBuildEditorConfig.editorconfig
        |                   HelloDotnetTen.ClassLibrary1.GlobalUsings.g.cs
        |                   
        \---HelloDotnetTen.Console
            |   appsettings.json
            |   HelloDotnetTen.Console.csproj
            |   Program.cs
            |   
            \---Exporters
                    FileActivityExporter.cs
                    FileExporterExtensions.cs
                    FileExporterOptions.cs
                    FileLogExporter.cs
                    FileMetricExporter.cs
                    


FILE CONTENTS:
==============

================================================================================
FILE: :\Users\kushal\source\repos\HelloDotnetTen\source\HelloDotnetTen\Directory.Build.props
SIZE: 0.51 KB
MODIFIED: 10/06/2025 15:32:23
================================================================================

<Project>
  <!-- Common properties for all projects -->
  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <LangVersion>latest</LangVersion>
  </PropertyGroup>

  <!-- Test project properties -->
  <PropertyGroup Condition="$(MSBuildProjectName.Contains('.Tests'))">
    <IsPackable>false</IsPackable>
  </PropertyGroup>
  
  <!-- Note: Package versions are now managed in Directory.Packages.props -->
</Project>



================================================================================
FILE: :\Users\kushal\source\repos\HelloDotnetTen\source\HelloDotnetTen\Directory.Packages.props
SIZE: 3.58 KB
MODIFIED: 12/05/2025 16:06:38
================================================================================

<Project>
  <PropertyGroup>
    <!-- Enable Central Package Management -->
    <ManagePackageVersionsCentrally>true</ManagePackageVersionsCentrally>
    <!-- Optional: Enforce that all projects must use centrally managed versions -->
    <CentralPackageTransitivePinningEnabled>true</CentralPackageTransitivePinningEnabled>
  </PropertyGroup>
  <ItemGroup>
    <!-- OpenTelemetry -->
    <PackageVersion Include="Microsoft.Extensions.Configuration" Version="10.0.0" />
    <PackageVersion Include="Microsoft.Extensions.Configuration.Binder" Version="10.0.0" />
    <PackageVersion Include="Microsoft.Extensions.Hosting" Version="10.0.0" />
    <PackageVersion Include="Microsoft.Extensions.Options" Version="10.0.0" />
    <PackageVersion Include="OpenTelemetry" Version="1.14.0" />
    <PackageVersion Include="OpenTelemetry.Exporter.Console" Version="1.14.0" />
    <PackageVersion Include="OpenTelemetry.Exporter.OpenTelemetryProtocol" Version="1.14.0" />
    <PackageVersion Include="OpenTelemetry.Extensions.Hosting" Version="1.14.0" />
    <PackageVersion Include="OpenTelemetry.Instrumentation.AspNetCore" Version="1.14.0" />
    <PackageVersion Include="OpenTelemetry.Instrumentation.EntityFrameworkCore" Version="1.14.0-beta.2" />
    <PackageVersion Include="OpenTelemetry.Instrumentation.Http" Version="1.14.0" />
    <PackageVersion Include="OpenTelemetry.Instrumentation.Process" Version="1.14.0-beta.2" />
    <PackageVersion Include="OpenTelemetry.Instrumentation.Runtime" Version="1.14.0" />
    <PackageVersion Include="Microsoft.EntityFrameworkCore" Version="10.0.0" />
    <PackageVersion Include="Microsoft.EntityFrameworkCore.Design" Version="10.0.0" />
    <PackageVersion Include="Microsoft.EntityFrameworkCore.Relational" Version="10.0.0" />
    <PackageVersion Include="Npgsql" Version="10.0.0" />
    <PackageVersion Include="Npgsql.EntityFrameworkCore.PostgreSQL" Version="10.0.0" />
    <PackageVersion Include="Microsoft.Build.Framework" Version="18.0.2" />
    <PackageVersion Include="Microsoft.Build.Locator" Version="1.11.2" />
    <PackageVersion Include="Microsoft.Build.Tasks.Core" Version="18.0.2" />
    <PackageVersion Include="Microsoft.Build.Utilities.Core" Version="18.0.2" />
    <PackageVersion Include="Microsoft.AspNetCore.OpenApi" Version="10.0.0" />
    <!-- Testing -->
    <PackageVersion Include="xunit" Version="2.9.3" />
    <PackageVersion Include="xunit.analyzers" Version="1.26.0" />
    <PackageVersion Include="xunit.runner.visualstudio" Version="3.1.5" />
    <PackageVersion Include="Microsoft.NET.Test.Sdk" Version="18.0.1" />
    <PackageVersion Include="coverlet.collector" Version="6.0.4" />
    <PackageVersion Include="Humanizer.Core" Version="3.0.1" />
    <PackageVersion Include="Microsoft.OpenApi" Version="2.3.5" />
    <PackageVersion Include="Newtonsoft.Json" Version="13.0.4" />
    <PackageVersion Include="Microsoft.Extensions.Logging.Abstractions" Version="10.0.0" />
    <PackageVersion Include="System.CodeDom" Version="10.0.0" />
    <PackageVersion Include="System.Configuration.ConfigurationManager" Version="10.0.0" />
    <PackageVersion Include="System.Formats.Nrbf" Version="10.0.0" />
    <PackageVersion Include="System.Resources.Extensions" Version="10.0.0" />
    <PackageVersion Include="System.Security.Cryptography.Pkcs" Version="10.0.0" />
    <PackageVersion Include="System.Security.Cryptography.ProtectedData" Version="10.0.0" />
    <PackageVersion Include="System.Diagnostics.EventLog" Version="10.0.0" />
    <PackageVersion Include="System.Security.Cryptography.Xml" Version="10.0.0" />
  </ItemGroup>
</Project>


================================================================================
FILE: :\Users\kushal\source\repos\HelloDotnetTen\source\HelloDotnetTen\HelloDotnetTen.ClassLibrary1\Class1.cs
SIZE: 3.65 KB
MODIFIED: 12/06/2025 15:25:27
================================================================================

using System.Diagnostics;
using System.Diagnostics.Metrics;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;

namespace HelloDotnetTen.ClassLibrary1;

public class Class1 : IClass1
{
    private static readonly ActivitySource ActivitySource = new("HelloDotnetTen.ClassLibrary1");
    private static readonly Meter Meter = new("HelloDotnetTen.ClassLibrary1");
    
    // Metrics
    private static readonly Counter<long> _initializationCounter = Meter.CreateCounter<long>(
        "class1.initializations",
        description: "Number of Class1 instances created");
    
    private static readonly Counter<long> _methodCallCounter = Meter.CreateCounter<long>(
        "class1.method_calls",
        description: "Number of times GetLengthOfInjectedProperty was called");
    
    private static readonly Histogram<int> _propertyLengthHistogram = Meter.CreateHistogram<int>(
        "class1.property_length",
        unit: "characters",
        description: "Distribution of property length values");
    
    private readonly Class1Options _options;
    private readonly ILogger<Class1> _logger;

    public Class1(IOptions<Class1Options> options, ILogger<Class1> logger)
    {
        _options = options.Value;
        _logger = logger;

        // Start a span for initialization
        using var activity = ActivitySource.StartActivity("Class1.Initialize");
        
        if (string.IsNullOrEmpty(_options.InjectedProperty1))
        {
            _logger.LogError("InjectedProperty1 cannot be null or empty");
            activity?.SetStatus(ActivityStatusCode.Error, "InjectedProperty1 validation failed");
            activity?.SetTag("error", true);
            activity?.SetTag("error.type", "ArgumentException");
            throw new ArgumentException("Property cannot be null or empty", nameof(_options.InjectedProperty1));
        }

        // Record successful initialization
        _initializationCounter.Add(1, 
            new KeyValuePair<string, object?>("status", "success"),
            new KeyValuePair<string, object?>("property_length", _options.InjectedProperty1.Length));
        
        activity?.SetTag("property.length", _options.InjectedProperty1.Length);
        activity?.SetTag("initialization.status", "success");
        
        _logger.LogInformation(
            "Class1 initialized successfully with InjectedProperty1: {Property} (Length: {Length})", 
            _options.InjectedProperty1,
            _options.InjectedProperty1.Length);
    }

    public int GetLengthOfInjectedProperty()
    {
        // Start trace span
        using var activity = ActivitySource.StartActivity("Class1.GetLengthOfInjectedProperty");
        
        // Record method call
        _methodCallCounter.Add(1);
        
        _logger.LogDebug("Getting length of InjectedProperty1");
        
        var startTime = Stopwatch.GetTimestamp();
        var length = _options.InjectedProperty1.Length;
        var elapsedMs = Stopwatch.GetElapsedTime(startTime).TotalMilliseconds;
        
        // Record metrics
        _propertyLengthHistogram.Record(length);
        
        // Add trace tags
        activity?.SetTag("property.length", length);
        activity?.SetTag("property.value", _options.InjectedProperty1);
        activity?.SetTag("operation.duration_ms", elapsedMs);
        activity?.SetStatus(ActivityStatusCode.Ok);
        
        // Log with structured data
        _logger.LogInformation(
            "InjectedProperty1 length is {Length} (calculated in {DurationMs}ms)", 
            length, 
            elapsedMs);
        
        return length;
    }
}



================================================================================
FILE: :\Users\kushal\source\repos\HelloDotnetTen\source\HelloDotnetTen\HelloDotnetTen.ClassLibrary1\Class1Options.cs
SIZE: 0.3 KB
MODIFIED: 12/05/2025 15:52:28
================================================================================

namespace HelloDotnetTen.ClassLibrary1;

// Specific options for Class 1. 
// This prevents "God Object" settings where unrelated configs reside in one class.
public class Class1Options
{
    public const string SectionName = "Class1";
    public required string InjectedProperty1 { get; set; }
}



================================================================================
FILE: :\Users\kushal\source\repos\HelloDotnetTen\source\HelloDotnetTen\HelloDotnetTen.ClassLibrary1\Class2.cs
SIZE: 3.65 KB
MODIFIED: 12/06/2025 15:25:38
================================================================================

using System.Diagnostics;
using System.Diagnostics.Metrics;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;

namespace HelloDotnetTen.ClassLibrary1;

public class Class2 : IClass2
{
    private static readonly ActivitySource ActivitySource = new("HelloDotnetTen.ClassLibrary1");
    private static readonly Meter Meter = new("HelloDotnetTen.ClassLibrary1");
    
    // Metrics
    private static readonly Counter<long> _initializationCounter = Meter.CreateCounter<long>(
        "class2.initializations",
        description: "Number of Class2 instances created");
    
    private static readonly Counter<long> _methodCallCounter = Meter.CreateCounter<long>(
        "class2.method_calls",
        description: "Number of times GetLengthOfInjectedProperty was called");
    
    private static readonly Histogram<int> _propertyLengthHistogram = Meter.CreateHistogram<int>(
        "class2.property_length",
        unit: "characters",
        description: "Distribution of property length values");
    
    private readonly Class2Options _options;
    private readonly ILogger<Class2> _logger;

    public Class2(IOptions<Class2Options> options, ILogger<Class2> logger)
    {
        _options = options.Value;
        _logger = logger;

        // Start a span for initialization
        using var activity = ActivitySource.StartActivity("Class2.Initialize");
        
        if (string.IsNullOrEmpty(_options.InjectedProperty1))
        {
            _logger.LogError("InjectedProperty1 cannot be null or empty");
            activity?.SetStatus(ActivityStatusCode.Error, "InjectedProperty1 validation failed");
            activity?.SetTag("error", true);
            activity?.SetTag("error.type", "ArgumentException");
            throw new ArgumentException("Property cannot be null or empty", nameof(_options.InjectedProperty1));
        }

        // Record successful initialization
        _initializationCounter.Add(1, 
            new KeyValuePair<string, object?>("status", "success"),
            new KeyValuePair<string, object?>("property_length", _options.InjectedProperty1.Length));
        
        activity?.SetTag("property.length", _options.InjectedProperty1.Length);
        activity?.SetTag("initialization.status", "success");
        
        _logger.LogInformation(
            "Class2 initialized successfully with InjectedProperty1: {Property} (Length: {Length})", 
            _options.InjectedProperty1,
            _options.InjectedProperty1.Length);
    }

    public int GetLengthOfInjectedProperty()
    {
        // Start trace span
        using var activity = ActivitySource.StartActivity("Class2.GetLengthOfInjectedProperty");
        
        // Record method call
        _methodCallCounter.Add(1);
        
        _logger.LogDebug("Getting length of InjectedProperty1");
        
        var startTime = Stopwatch.GetTimestamp();
        var length = _options.InjectedProperty1.Length;
        var elapsedMs = Stopwatch.GetElapsedTime(startTime).TotalMilliseconds;
        
        // Record metrics
        _propertyLengthHistogram.Record(length);
        
        // Add trace tags
        activity?.SetTag("property.length", length);
        activity?.SetTag("property.value", _options.InjectedProperty1);
        activity?.SetTag("operation.duration_ms", elapsedMs);
        activity?.SetStatus(ActivityStatusCode.Ok);
        
        // Log with structured data
        _logger.LogInformation(
            "InjectedProperty1 length is {Length} (calculated in {DurationMs}ms)", 
            length, 
            elapsedMs);
        
        return length;
    }
}



================================================================================
FILE: :\Users\kushal\source\repos\HelloDotnetTen\source\HelloDotnetTen\HelloDotnetTen.ClassLibrary1\Class2Options.cs
SIZE: 0.18 KB
MODIFIED: 12/05/2025 15:52:45
================================================================================

namespace HelloDotnetTen.ClassLibrary1;

public class Class2Options
{
    public const string SectionName = "Class2";
    public required string InjectedProperty1 { get; set; }
}



================================================================================
FILE: :\Users\kushal\source\repos\HelloDotnetTen\source\HelloDotnetTen\HelloDotnetTen.ClassLibrary1\ClassLibrary1Settings.cs
SIZE: 0.15 KB
MODIFIED: 12/05/2025 15:26:51
================================================================================

namespace HelloDotnetTen.ClassLibrary1;

public sealed class ClassLibrary1Settings
{
    public required string InjectedProperty1 { get; init; }
}



================================================================================
FILE: :\Users\kushal\source\repos\HelloDotnetTen\source\HelloDotnetTen\HelloDotnetTen.ClassLibrary1\HelloDotnetTen.ClassLibrary1.csproj
SIZE: 0.53 KB
MODIFIED: 12/05/2025 16:23:45
================================================================================

<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.Extensions.Configuration" />
    <PackageReference Include="Microsoft.Extensions.Configuration.Binder" />
    <PackageReference Include="Microsoft.Extensions.Logging.Abstractions" />
    <PackageReference Include="Microsoft.Extensions.Options" />
  </ItemGroup>

</Project>



================================================================================
FILE: :\Users\kushal\source\repos\HelloDotnetTen\source\HelloDotnetTen\HelloDotnetTen.ClassLibrary1\IClass1.cs
SIZE: 0.12 KB
MODIFIED: 12/05/2025 15:51:47
================================================================================

namespace HelloDotnetTen.ClassLibrary1;

public interface IClass1
{
    int GetLengthOfInjectedProperty();
}



================================================================================
FILE: :\Users\kushal\source\repos\HelloDotnetTen\source\HelloDotnetTen\HelloDotnetTen.ClassLibrary1\IClass2.cs
SIZE: 0.12 KB
MODIFIED: 12/05/2025 15:52:09
================================================================================

namespace HelloDotnetTen.ClassLibrary1;

public interface IClass2
{
    int GetLengthOfInjectedProperty();
}



================================================================================
FILE: :\Users\kushal\source\repos\HelloDotnetTen\source\HelloDotnetTen\HelloDotnetTen.ClassLibrary1\ServiceCollectionExtensions.cs
SIZE: 1.11 KB
MODIFIED: 12/05/2025 16:12:37
================================================================================

using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;

namespace HelloDotnetTen.ClassLibrary1;

public static class ServiceCollectionExtensions
{
    /// <summary>
    /// Registers the library services and binds configuration automatically.
    /// This encapsulates the library's complexity from the consumer.
    /// </summary>
    public static IServiceCollection AddHelloDotnetLibrary(this IServiceCollection services, IConfiguration configuration)
    {
        // 1. Bind Options
        // We look for sections named "Class1" and "Class2" in the root config
        services.Configure<Class1Options>(options => configuration.GetSection(Class1Options.SectionName).Bind(options));
        services.Configure<Class2Options>(options => configuration.GetSection(Class2Options.SectionName).Bind(options));

        // 2. Register Services
        // We register interfaces, allowing the implementation to change without breaking consumers
        services.AddSingleton<IClass1, Class1>();
        services.AddSingleton<IClass2, Class2>();

        return services;
    }
}



================================================================================
FILE: :\Users\kushal\source\repos\HelloDotnetTen\source\HelloDotnetTen\HelloDotnetTen.Console\appsettings.json
SIZE: 0.32 KB
MODIFIED: 12/05/2025 18:00:49
================================================================================

{
    "Logging": {
        "LogLevel": {
            "Default": "Information",
            "Microsoft.Hosting.Lifetime": "Information"
        }
    },
    "Class1": {
        "InjectedProperty1": "Hello from Class 1 Config"
    },
    "Class2": {
        "InjectedProperty1": "Greetings from Class 2"
    }
}



================================================================================
FILE: :\Users\kushal\source\repos\HelloDotnetTen\source\HelloDotnetTen\HelloDotnetTen.Console\Exporters\FileActivityExporter.cs
SIZE: 6.58 KB
MODIFIED: 12/07/2025 10:34:42
================================================================================

using System.Diagnostics;
using System.Text;
using System.Text.Json;
using OpenTelemetry;

namespace HelloDotnetTen.Console.Exporters;

/// <summary>
/// Custom file exporter for OpenTelemetry traces (Activities).
/// Writes traces to JSON files with run-based separation, daily rotation, and size limits.
/// Each application run creates new files (never appends to existing files from previous runs).
/// </summary>
public class FileActivityExporter : BaseExporter<Activity>
{
    private readonly FileExporterOptions _options;
    private readonly object _lock = new();
    private StreamWriter? _writer;
    private string _currentFilePath = string.Empty;
    private DateTime _currentFileDate;
    private long _currentFileSize;
    private int _currentFileNumber;
    private bool _isFirstRecord = true;
    private readonly JsonSerializerOptions _jsonOptions;

    public FileActivityExporter(FileExporterOptions options)
    {
        _options = options ?? throw new ArgumentNullException(nameof(options));
        _jsonOptions = new JsonSerializerOptions 
        { 
            WriteIndented = true,
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        };
        EnsureDirectoryExists();
    }

    public override ExportResult Export(in Batch<Activity> batch)
    {
        using var scope = SuppressInstrumentationScope.Begin();
        
        try
        {
            lock (_lock)
            {
                EnsureWriter();
                
                foreach (var activity in batch)
                {
                    var record = SerializeActivity(activity);
                    var json = JsonSerializer.Serialize(record, _jsonOptions);
                    
                    var bytesToWrite = Encoding.UTF8.GetByteCount(json) + Environment.NewLine.Length + 1;
                    
                    if (ShouldRotate(bytesToWrite))
                    {
                        RotateFile();
                    }
                    
                    if (!_isFirstRecord)
                    {
                        _writer!.WriteLine(",");
                    }
                    else
                    {
                        _isFirstRecord = false;
                    }
                    
                    _writer!.Write(json);
                    _currentFileSize += bytesToWrite;
                }
                
                _writer!.Flush();
            }
            
            return ExportResult.Success;
        }
        catch (Exception ex)
        {
            System.Console.Error.WriteLine($"[FileActivityExporter] Export failed: {ex.Message}");
            return ExportResult.Failure;
        }
    }

    private bool ShouldRotate(long bytesToWrite)
    {
        if (_currentFileSize + bytesToWrite > _options.MaxFileSizeBytes)
            return true;
        
        if (_currentFileDate != DateTime.UtcNow.Date)
            return true;
        
        return false;
    }

    private object SerializeActivity(Activity activity)
    {
        return new
        {
            Timestamp = activity.StartTimeUtc.ToString("O"),
            TraceId = activity.TraceId.ToString(),
            SpanId = activity.SpanId.ToString(),
            ParentSpanId = activity.ParentSpanId.ToString(),
            OperationName = activity.OperationName,
            DisplayName = activity.DisplayName,
            Kind = activity.Kind.ToString(),
            Status = new
            {
                Code = activity.Status.ToString(),
                Description = activity.StatusDescription
            },
            StartTime = activity.StartTimeUtc.ToString("O"),
            EndTime = (activity.StartTimeUtc + activity.Duration).ToString("O"),
            DurationMs = activity.Duration.TotalMilliseconds,
            Tags = activity.TagObjects.ToDictionary(t => t.Key, t => t.Value?.ToString()),
            Events = activity.Events.Select(e => new
            {
                Name = e.Name,
                Timestamp = e.Timestamp.ToString("O"),
                Attributes = e.Tags.ToDictionary(t => t.Key, t => t.Value?.ToString())
            }).ToArray(),
            Links = activity.Links.Select(l => new
            {
                TraceId = l.Context.TraceId.ToString(),
                SpanId = l.Context.SpanId.ToString()
            }).ToArray(),
            Resource = ParentProvider?.GetResource()?.Attributes
                .ToDictionary(a => a.Key, a => a.Value?.ToString())
        };
    }

    private void EnsureDirectoryExists()
    {
        if (!Directory.Exists(_options.Directory))
        {
            Directory.CreateDirectory(_options.Directory);
        }
    }

    private void EnsureWriter()
    {
        var today = DateTime.UtcNow.Date;
        
        if (_writer == null)
        {
            OpenNewFile(today);
        }
        else if (_currentFileDate != today)
        {
            RotateFile();
        }
    }

    private void OpenNewFile(DateTime date)
    {
        _currentFileDate = date;
        _currentFileNumber = 0;
        _currentFilePath = GetFilePath(date, _currentFileNumber);
        
        _writer = new StreamWriter(_currentFilePath, append: false, Encoding.UTF8);
        _currentFileSize = 0;
        _isFirstRecord = true;
        
        _writer.WriteLine("[");
        _currentFileSize += 2;
    }

    private void RotateFile()
    {
        CloseWriter();
        
        _currentFileNumber++;
        _currentFileDate = DateTime.UtcNow.Date;
        _currentFilePath = GetFilePath(_currentFileDate, _currentFileNumber);
        
        _writer = new StreamWriter(_currentFilePath, append: false, Encoding.UTF8);
        _currentFileSize = 0;
        _isFirstRecord = true;
        
        _writer.WriteLine("[");
        _currentFileSize += 2;
    }

    private string GetFilePath(DateTime date, int fileNumber)
    {
        var fileName = fileNumber == 0
            ? $"traces_{_options.RunId}.json"
            : $"traces_{_options.RunId}_{fileNumber:D3}.json";
        return Path.Combine(_options.Directory, fileName);
    }

    private void CloseWriter()
    {
        if (_writer != null)
        {
            _writer.WriteLine();
            _writer.WriteLine("]");
            _writer.Flush();
            _writer.Dispose();
            _writer = null;
        }
    }

    protected override bool OnShutdown(int timeoutMilliseconds)
    {
        lock (_lock)
        {
            CloseWriter();
        }
        return true;
    }
}



================================================================================
FILE: :\Users\kushal\source\repos\HelloDotnetTen\source\HelloDotnetTen\HelloDotnetTen.Console\Exporters\FileExporterExtensions.cs
SIZE: 3.45 KB
MODIFIED: 12/07/2025 10:34:16
================================================================================

using OpenTelemetry;
using OpenTelemetry.Logs;
using OpenTelemetry.Metrics;
using OpenTelemetry.Trace;

namespace HelloDotnetTen.Console.Exporters;

/// <summary>
/// Extension methods for adding file exporters to OpenTelemetry builders.
/// </summary>
public static class FileExporterExtensions
{
    /// <summary>
    /// Adds a file exporter for traces to the TracerProviderBuilder.
    /// </summary>
    public static TracerProviderBuilder AddFileExporter(
        this TracerProviderBuilder builder,
        FileExporterOptions? options = null)
    {
        options ??= FileExporterOptions.Default;
        
        return builder.AddProcessor(
            new BatchActivityExportProcessor(new FileActivityExporter(options)));
    }

    /// <summary>
    /// Adds a file exporter for traces with custom configuration.
    /// </summary>
    public static TracerProviderBuilder AddFileExporter(
        this TracerProviderBuilder builder,
        Action<FileExporterOptions> configure)
    {
        var options = new FileExporterOptions();
        configure(options);
        return builder.AddFileExporter(options);
    }

    /// <summary>
    /// Adds a file exporter for metrics to the MeterProviderBuilder.
    /// </summary>
    public static MeterProviderBuilder AddFileExporter(
        this MeterProviderBuilder builder,
        FileExporterOptions? options = null)
    {
        options ??= FileExporterOptions.Default;
        
        return builder.AddReader(
            new PeriodicExportingMetricReader(
                new FileMetricExporter(options),
                exportIntervalMilliseconds: 10000));
    }

    /// <summary>
    /// Adds a file exporter for metrics with custom configuration.
    /// </summary>
    public static MeterProviderBuilder AddFileExporter(
        this MeterProviderBuilder builder,
        Action<FileExporterOptions> configure)
    {
        var options = new FileExporterOptions();
        configure(options);
        return builder.AddFileExporter(options);
    }

    /// <summary>
    /// Adds a file exporter for metrics with custom export interval.
    /// </summary>
    public static MeterProviderBuilder AddFileExporter(
        this MeterProviderBuilder builder,
        FileExporterOptions options,
        int exportIntervalMilliseconds)
    {
        return builder.AddReader(
            new PeriodicExportingMetricReader(
                new FileMetricExporter(options),
                exportIntervalMilliseconds: exportIntervalMilliseconds));
    }

    /// <summary>
    /// Adds a file exporter for logs to the OpenTelemetryLoggerOptions.
    /// </summary>
    public static OpenTelemetryLoggerOptions AddFileExporter(
        this OpenTelemetryLoggerOptions options,
        FileExporterOptions? exporterOptions = null)
    {
        exporterOptions ??= FileExporterOptions.Default;
        
        return options.AddProcessor(
            new BatchLogRecordExportProcessor(new FileLogExporter(exporterOptions)));
    }

    /// <summary>
    /// Adds a file exporter for logs with custom configuration.
    /// </summary>
    public static OpenTelemetryLoggerOptions AddFileExporter(
        this OpenTelemetryLoggerOptions options,
        Action<FileExporterOptions> configure)
    {
        var exporterOptions = new FileExporterOptions();
        configure(exporterOptions);
        return options.AddFileExporter(exporterOptions);
    }
}



================================================================================
FILE: :\Users\kushal\source\repos\HelloDotnetTen\source\HelloDotnetTen\HelloDotnetTen.Console\Exporters\FileExporterOptions.cs
SIZE: 3.24 KB
MODIFIED: 12/07/2025 10:35:32
================================================================================

namespace HelloDotnetTen.Console.Exporters;

/// <summary>
/// Configuration options for file-based OpenTelemetry exporters.
/// </summary>
public class FileExporterOptions
{
    /// <summary>
    /// The directory where telemetry files will be written.
    /// If not specified, uses the XDG data directory pattern:
    /// - Windows: %LOCALAPPDATA%/HelloDotnetTen/telemetry
    /// - Linux: ~/.local/share/HelloDotnetTen/telemetry
    /// - macOS: ~/Library/Application Support/HelloDotnetTen/telemetry
    /// </summary>
    public string Directory { get; set; } = GetDefaultDirectory();

    /// <summary>
    /// Maximum file size in bytes before rotation occurs.
    /// Default is 25MB (25 * 1024 * 1024 bytes).
    /// </summary>
    public long MaxFileSizeBytes { get; set; } = 25 * 1024 * 1024; // 25MB

    /// <summary>
    /// The application name used for the directory structure.
    /// </summary>
    public string ApplicationName { get; set; } = "HelloDotnetTen";

    /// <summary>
    /// Unique identifier for this application run.
    /// Generated at startup to ensure each run creates new files.
    /// </summary>
    public string RunId { get; set; } = DateTime.UtcNow.ToString("yyyyMMdd_HHmmss");

    /// <summary>
    /// Gets the default telemetry directory following XDG/platform conventions.
    /// </summary>
    private static string GetDefaultDirectory()
    {
        string baseDir;

        if (OperatingSystem.IsWindows())
        {
            // Windows: Use LocalAppData
            baseDir = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
        }
        else if (OperatingSystem.IsMacOS())
        {
            // macOS: Use ~/Library/Application Support
            baseDir = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);
        }
        else
        {
            // Linux/Unix: Use XDG_DATA_HOME or ~/.local/share
            var xdgDataHome = Environment.GetEnvironmentVariable("XDG_DATA_HOME");
            baseDir = !string.IsNullOrEmpty(xdgDataHome) 
                ? xdgDataHome 
                : Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), ".local", "share");
        }

        return Path.Combine(baseDir, "HelloDotnetTen", "telemetry");
    }

    /// <summary>
    /// Creates options with default values.
    /// </summary>
    public static FileExporterOptions Default => new();

    /// <summary>
    /// Creates options for the specified directory with default 25MB size limit.
    /// </summary>
    public static FileExporterOptions ForDirectory(string directory) => new()
    {
        Directory = directory
    };

    /// <summary>
    /// Creates options for the specified directory and max file size in megabytes.
    /// </summary>
    public static FileExporterOptions Create(string directory, int maxFileSizeMb) => new()
    {
        Directory = directory,
        MaxFileSizeBytes = maxFileSizeMb * 1024L * 1024L
    };

    /// <summary>
    /// Creates options with a specific run ID (useful for testing or correlation).
    /// </summary>
    public static FileExporterOptions CreateWithRunId(string runId) => new()
    {
        RunId = runId
    };
}



================================================================================
FILE: :\Users\kushal\source\repos\HelloDotnetTen\source\HelloDotnetTen\HelloDotnetTen.Console\Exporters\FileLogExporter.cs
SIZE: 7.13 KB
MODIFIED: 12/07/2025 10:35:15
================================================================================

using System.Text;
using System.Text.Json;
using OpenTelemetry;
using OpenTelemetry.Logs;

namespace HelloDotnetTen.Console.Exporters;

/// <summary>
/// Custom file exporter for OpenTelemetry logs.
/// Writes logs to JSON files with run-based separation, daily rotation, and size limits.
/// Each application run creates new files (never appends to existing files from previous runs).
/// </summary>
public class FileLogExporter : BaseExporter<LogRecord>
{
    private readonly FileExporterOptions _options;
    private readonly object _lock = new();
    private StreamWriter? _writer;
    private string _currentFilePath = string.Empty;
    private DateTime _currentFileDate;
    private long _currentFileSize;
    private int _currentFileNumber;
    private bool _isFirstRecord = true;
    private readonly JsonSerializerOptions _jsonOptions;

    public FileLogExporter(FileExporterOptions options)
    {
        _options = options ?? throw new ArgumentNullException(nameof(options));
        _jsonOptions = new JsonSerializerOptions 
        { 
            WriteIndented = true,
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        };
        EnsureDirectoryExists();
    }

    public override ExportResult Export(in Batch<LogRecord> batch)
    {
        using var scope = SuppressInstrumentationScope.Begin();
        
        try
        {
            lock (_lock)
            {
                EnsureWriter();
                
                foreach (var logRecord in batch)
                {
                    var record = SerializeLogRecord(logRecord);
                    var json = JsonSerializer.Serialize(record, _jsonOptions);
                    
                    var bytesToWrite = Encoding.UTF8.GetByteCount(json) + Environment.NewLine.Length + 1; // +1 for comma
                    
                    // Check if we need to rotate (size limit or day change)
                    if (ShouldRotate(bytesToWrite))
                    {
                        RotateFile();
                    }
                    
                    // Write comma separator if not first record
                    if (!_isFirstRecord)
                    {
                        _writer!.WriteLine(",");
                    }
                    else
                    {
                        _isFirstRecord = false;
                    }
                    
                    _writer!.Write(json);
                    _currentFileSize += bytesToWrite;
                }
                
                _writer!.Flush();
            }
            
            return ExportResult.Success;
        }
        catch (Exception ex)
        {
            System.Console.Error.WriteLine($"[FileLogExporter] Export failed: {ex.Message}");
            return ExportResult.Failure;
        }
    }

    private bool ShouldRotate(long bytesToWrite)
    {
        // Rotate if size would exceed limit
        if (_currentFileSize + bytesToWrite > _options.MaxFileSizeBytes)
            return true;
        
        // Rotate if day has changed (for long-running applications)
        if (_currentFileDate != DateTime.UtcNow.Date)
            return true;
        
        return false;
    }

    private object SerializeLogRecord(LogRecord logRecord)
    {
        var attributes = new Dictionary<string, object?>();
        
        if (logRecord.Attributes != null)
        {
            foreach (var attr in logRecord.Attributes)
            {
                attributes[attr.Key] = attr.Value;
            }
        }

        logRecord.ForEachScope(ProcessScope, attributes);

        return new
        {
            Timestamp = logRecord.Timestamp.ToString("O"),
            TraceId = logRecord.TraceId.ToString(),
            SpanId = logRecord.SpanId.ToString(),
            TraceFlags = logRecord.TraceFlags.ToString(),
            CategoryName = logRecord.CategoryName,
            LogLevel = logRecord.LogLevel.ToString(),
            Body = logRecord.Body,
            FormattedMessage = logRecord.FormattedMessage,
            Attributes = attributes,
            EventId = logRecord.EventId.Id != 0 ? 
                new { logRecord.EventId.Id, logRecord.EventId.Name } : null,
            Exception = logRecord.Exception?.ToString(),
            Resource = ParentProvider?.GetResource()?.Attributes
                .ToDictionary(a => a.Key, a => a.Value?.ToString())
        };
    }

    private static readonly Action<LogRecordScope, Dictionary<string, object?>> ProcessScope = 
        (scope, attributes) =>
        {
            foreach (var item in scope)
            {
                attributes[$"scope.{item.Key}"] = item.Value;
            }
        };

    private void EnsureDirectoryExists()
    {
        if (!Directory.Exists(_options.Directory))
        {
            Directory.CreateDirectory(_options.Directory);
        }
    }

    private void EnsureWriter()
    {
        var today = DateTime.UtcNow.Date;
        
        if (_writer == null)
        {
            OpenNewFile(today);
        }
        else if (_currentFileDate != today)
        {
            // Day changed - rotate to new file
            RotateFile();
        }
    }

    private void OpenNewFile(DateTime date)
    {
        _currentFileDate = date;
        _currentFileNumber = 0;
        _currentFilePath = GetFilePath(date, _currentFileNumber);
        
        // For this run, always create a new file (never append)
        _writer = new StreamWriter(_currentFilePath, append: false, Encoding.UTF8);
        _currentFileSize = 0;
        _isFirstRecord = true;
        
        // Start JSON array
        _writer.WriteLine("[");
        _currentFileSize += 2; // "[\n"
    }

    private void RotateFile()
    {
        CloseWriter();
        
        _currentFileNumber++;
        _currentFileDate = DateTime.UtcNow.Date;
        _currentFilePath = GetFilePath(_currentFileDate, _currentFileNumber);
        
        _writer = new StreamWriter(_currentFilePath, append: false, Encoding.UTF8);
        _currentFileSize = 0;
        _isFirstRecord = true;
        
        // Start JSON array
        _writer.WriteLine("[");
        _currentFileSize += 2;
    }

    private string GetFilePath(DateTime date, int fileNumber)
    {
        // Format: logs_YYYYMMDD_HHmmss_NNN.json
        // The RunId contains the start time, fileNumber handles rotation within a run
        var fileName = fileNumber == 0
            ? $"logs_{_options.RunId}.json"
            : $"logs_{_options.RunId}_{fileNumber:D3}.json";
        return Path.Combine(_options.Directory, fileName);
    }

    private void CloseWriter()
    {
        if (_writer != null)
        {
            // Close JSON array
            _writer.WriteLine();
            _writer.WriteLine("]");
            _writer.Flush();
            _writer.Dispose();
            _writer = null;
        }
    }

    protected override bool OnShutdown(int timeoutMilliseconds)
    {
        lock (_lock)
        {
            CloseWriter();
        }
        return true;
    }
}



================================================================================
FILE: :\Users\kushal\source\repos\HelloDotnetTen\source\HelloDotnetTen\HelloDotnetTen.Console\Exporters\FileMetricExporter.cs
SIZE: 8.26 KB
MODIFIED: 12/07/2025 10:34:57
================================================================================

using System.Text;
using System.Text.Json;
using OpenTelemetry;
using OpenTelemetry.Metrics;

namespace HelloDotnetTen.Console.Exporters;

/// <summary>
/// Custom file exporter for OpenTelemetry metrics.
/// Writes metrics to JSON files with run-based separation, daily rotation, and size limits.
/// Each application run creates new files (never appends to existing files from previous runs).
/// </summary>
public class FileMetricExporter : BaseExporter<Metric>
{
    private readonly FileExporterOptions _options;
    private readonly object _lock = new();
    private StreamWriter? _writer;
    private string _currentFilePath = string.Empty;
    private DateTime _currentFileDate;
    private long _currentFileSize;
    private int _currentFileNumber;
    private bool _isFirstRecord = true;
    private readonly JsonSerializerOptions _jsonOptions;

    public FileMetricExporter(FileExporterOptions options)
    {
        _options = options ?? throw new ArgumentNullException(nameof(options));
        _jsonOptions = new JsonSerializerOptions 
        { 
            WriteIndented = true,
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        };
        EnsureDirectoryExists();
    }

    public override ExportResult Export(in Batch<Metric> batch)
    {
        using var scope = SuppressInstrumentationScope.Begin();
        
        try
        {
            lock (_lock)
            {
                EnsureWriter();
                
                foreach (var metric in batch)
                {
                    foreach (var metricPoint in metric.GetMetricPoints())
                    {
                        var record = SerializeMetricPoint(metric, metricPoint);
                        var json = JsonSerializer.Serialize(record, _jsonOptions);
                        
                        var bytesToWrite = Encoding.UTF8.GetByteCount(json) + Environment.NewLine.Length + 1;
                        
                        if (ShouldRotate(bytesToWrite))
                        {
                            RotateFile();
                        }
                        
                        if (!_isFirstRecord)
                        {
                            _writer!.WriteLine(",");
                        }
                        else
                        {
                            _isFirstRecord = false;
                        }
                        
                        _writer!.Write(json);
                        _currentFileSize += bytesToWrite;
                    }
                }
                
                _writer!.Flush();
            }
            
            return ExportResult.Success;
        }
        catch (Exception ex)
        {
            System.Console.Error.WriteLine($"[FileMetricExporter] Export failed: {ex.Message}");
            return ExportResult.Failure;
        }
    }

    private bool ShouldRotate(long bytesToWrite)
    {
        if (_currentFileSize + bytesToWrite > _options.MaxFileSizeBytes)
            return true;
        
        if (_currentFileDate != DateTime.UtcNow.Date)
            return true;
        
        return false;
    }

    private object SerializeMetricPoint(Metric metric, MetricPoint metricPoint)
    {
        var tags = new Dictionary<string, string?>();
        foreach (var tag in metricPoint.Tags)
        {
            tags[tag.Key] = tag.Value?.ToString();
        }

        object? value = metric.MetricType switch
        {
            MetricType.LongSum => metricPoint.GetSumLong(),
            MetricType.DoubleSum => metricPoint.GetSumDouble(),
            MetricType.LongGauge => metricPoint.GetGaugeLastValueLong(),
            MetricType.DoubleGauge => metricPoint.GetGaugeLastValueDouble(),
            MetricType.Histogram => SerializeHistogram(metricPoint),
            MetricType.ExponentialHistogram => SerializeExponentialHistogram(metricPoint),
            _ => null
        };

        return new
        {
            Timestamp = metricPoint.EndTime.ToString("O"),
            Name = metric.Name,
            Description = metric.Description,
            Unit = metric.Unit,
            Type = metric.MetricType.ToString(),
            Tags = tags,
            Value = value,
            StartTime = metricPoint.StartTime.ToString("O"),
            EndTime = metricPoint.EndTime.ToString("O"),
            Resource = ParentProvider?.GetResource()?.Attributes
                .ToDictionary(a => a.Key, a => a.Value?.ToString())
        };
    }

    private object SerializeHistogram(MetricPoint metricPoint)
    {
        var bucketCounts = new List<long>();
        var explicitBounds = new List<double>();
        
        foreach (var histogramBucket in metricPoint.GetHistogramBuckets())
        {
            bucketCounts.Add(histogramBucket.BucketCount);
            if (histogramBucket.ExplicitBound != double.PositiveInfinity)
            {
                explicitBounds.Add(histogramBucket.ExplicitBound);
            }
        }

        return new
        {
            Count = metricPoint.GetHistogramCount(),
            Sum = metricPoint.GetHistogramSum(),
            BucketCounts = bucketCounts,
            ExplicitBounds = explicitBounds,
            Min = metricPoint.TryGetHistogramMinMaxValues(out var min, out _) ? min : (double?)null,
            Max = metricPoint.TryGetHistogramMinMaxValues(out _, out var max) ? max : (double?)null
        };
    }

    private object SerializeExponentialHistogram(MetricPoint metricPoint)
    {
        var data = metricPoint.GetExponentialHistogramData();
        
        return new
        {
            Scale = data.Scale,
            ZeroCount = data.ZeroCount,
            PositiveBuckets = SerializeExponentialBuckets(data.PositiveBuckets),
        };
    }

    private object SerializeExponentialBuckets(ExponentialHistogramBuckets buckets)
    {
        var bucketCounts = new List<long>();
        foreach (var count in buckets)
        {
            bucketCounts.Add(count);
        }
        
        return new
        {
            Offset = buckets.Offset,
            BucketCounts = bucketCounts
        };
    }

    private void EnsureDirectoryExists()
    {
        if (!Directory.Exists(_options.Directory))
        {
            Directory.CreateDirectory(_options.Directory);
        }
    }

    private void EnsureWriter()
    {
        var today = DateTime.UtcNow.Date;
        
        if (_writer == null)
        {
            OpenNewFile(today);
        }
        else if (_currentFileDate != today)
        {
            RotateFile();
        }
    }

    private void OpenNewFile(DateTime date)
    {
        _currentFileDate = date;
        _currentFileNumber = 0;
        _currentFilePath = GetFilePath(date, _currentFileNumber);
        
        _writer = new StreamWriter(_currentFilePath, append: false, Encoding.UTF8);
        _currentFileSize = 0;
        _isFirstRecord = true;
        
        _writer.WriteLine("[");
        _currentFileSize += 2;
    }

    private void RotateFile()
    {
        CloseWriter();
        
        _currentFileNumber++;
        _currentFileDate = DateTime.UtcNow.Date;
        _currentFilePath = GetFilePath(_currentFileDate, _currentFileNumber);
        
        _writer = new StreamWriter(_currentFilePath, append: false, Encoding.UTF8);
        _currentFileSize = 0;
        _isFirstRecord = true;
        
        _writer.WriteLine("[");
        _currentFileSize += 2;
    }

    private string GetFilePath(DateTime date, int fileNumber)
    {
        var fileName = fileNumber == 0
            ? $"metrics_{_options.RunId}.json"
            : $"metrics_{_options.RunId}_{fileNumber:D3}.json";
        return Path.Combine(_options.Directory, fileName);
    }

    private void CloseWriter()
    {
        if (_writer != null)
        {
            _writer.WriteLine();
            _writer.WriteLine("]");
            _writer.Flush();
            _writer.Dispose();
            _writer = null;
        }
    }

    protected override bool OnShutdown(int timeoutMilliseconds)
    {
        lock (_lock)
        {
            CloseWriter();
        }
        return true;
    }
}



================================================================================
FILE: :\Users\kushal\source\repos\HelloDotnetTen\source\HelloDotnetTen\HelloDotnetTen.Console\HelloDotnetTen.Console.csproj
SIZE: 0.98 KB
MODIFIED: 12/05/2025 18:03:25
================================================================================

<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.Extensions.Hosting" />
    <PackageReference Include="OpenTelemetry.Exporter.OpenTelemetryProtocol" />
    <PackageReference Include="OpenTelemetry.Extensions.Hosting" />
    <PackageReference Include="OpenTelemetry.Exporter.Console" />
    <PackageReference Include="OpenTelemetry.Instrumentation.Runtime" />
    <PackageReference Include="OpenTelemetry.Instrumentation.Process" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\HelloDotnetTen.ClassLibrary1\HelloDotnetTen.ClassLibrary1.csproj" />
  </ItemGroup>

  <ItemGroup>
    <None Update="appsettings.json">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </None>
  </ItemGroup>

</Project>



================================================================================
FILE: :\Users\kushal\source\repos\HelloDotnetTen\source\HelloDotnetTen\HelloDotnetTen.Console\Program.cs
SIZE: 5.98 KB
MODIFIED: 12/07/2025 10:34:03
================================================================================

using HelloDotnetTen.ClassLibrary1;
using HelloDotnetTen.Console.Exporters;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using OpenTelemetry.Logs;
using OpenTelemetry.Metrics;
using OpenTelemetry.Resources;
using OpenTelemetry.Trace;

var builder = Host.CreateApplicationBuilder(args);

// Uptrace configuration (keeping existing OTLP export)
const string uptraceEndpoint = "https://api.uptrace.dev";
const string uptraceDsn = "uptrace-dsn=https://20MWRhNvOdzl6e7VCczHvA@api.uptrace.dev?grpc=4317";

// File exporter configuration
// Uses XDG-style directories by default:
// - Windows: %LOCALAPPDATA%/HelloDotnetTen/telemetry
// - Linux: ~/.local/share/HelloDotnetTen/telemetry
// - macOS: ~/Library/Application Support/HelloDotnetTen/telemetry
// Each run creates new files with timestamp in filename (never appends)
var fileExporterOptions = new FileExporterOptions
{
    MaxFileSizeBytes = 25 * 1024 * 1024 // 25MB
};

Console.WriteLine($"[Telemetry] Writing to: {fileExporterOptions.Directory}");
Console.WriteLine($"[Telemetry] Run ID: {fileExporterOptions.RunId}");

builder.Services.AddOpenTelemetry()
    .ConfigureResource(resource => resource
        .AddService(
            serviceName: "HelloDotnetTen.Console",
            serviceVersion: "1.0.0"))
    .WithTracing(tracing =>
    {
        tracing
            .AddSource("HelloDotnetTen.ClassLibrary1")
            // Console exporter for immediate visibility
            .AddConsoleExporter()
            // File exporter for persistent storage
            .AddFileExporter(fileExporterOptions)
            // OTLP exporter for Uptrace
            .AddOtlpExporter(options =>
            {
                options.Endpoint = new Uri(uptraceEndpoint);
                options.Protocol = OpenTelemetry.Exporter.OtlpExportProtocol.HttpProtobuf;
                options.Headers = uptraceDsn;
            });
    })
    .WithMetrics(metrics =>
    {
        metrics
            .AddMeter("HelloDotnetTen.ClassLibrary1")
            .AddRuntimeInstrumentation()
            .AddProcessInstrumentation()
            // Console exporter for immediate visibility
            .AddConsoleExporter()
            // File exporter for persistent storage (exports every 10 seconds)
            .AddFileExporter(fileExporterOptions)
            // OTLP exporter for Uptrace
            .AddOtlpExporter((options, readerOptions) =>
            {
                options.Endpoint = new Uri(uptraceEndpoint);
                options.Protocol = OpenTelemetry.Exporter.OtlpExportProtocol.HttpProtobuf;
                options.Headers = uptraceDsn;
                readerOptions.TemporalityPreference = MetricReaderTemporalityPreference.Delta;
            });
    });

// Configure logging with OpenTelemetry
builder.Logging.AddOpenTelemetry(options =>
{
    options.SetResourceBuilder(ResourceBuilder.CreateDefault()
        .AddService(
            serviceName: "HelloDotnetTen.Console",
            serviceVersion: "1.0.0"));
    options.IncludeScopes = true;
    options.IncludeFormattedMessage = true;
    // Console exporter for immediate visibility
    options.AddConsoleExporter();
    // File exporter for persistent storage
    options.AddFileExporter(fileExporterOptions);
    // OTLP exporter for Uptrace
    options.AddOtlpExporter(otlpOptions =>
    {
        otlpOptions.Endpoint = new Uri(uptraceEndpoint);
        otlpOptions.Protocol = OpenTelemetry.Exporter.OtlpExportProtocol.HttpProtobuf;
        otlpOptions.Headers = uptraceDsn;
    });
});

builder.Services.AddHelloDotnetLibrary(builder.Configuration);

var app = builder.Build();

// Get logger to demonstrate logging
var logger = app.Services.GetRequiredService<ILogger<Program>>();

logger.LogInformation("Starting HelloDotnetTen Console Application");
logger.LogInformation("========================================");

// Test the services
var c1 = app.Services.GetRequiredService<IClass1>();
var c2 = app.Services.GetRequiredService<IClass2>();

logger.LogInformation("--- Scenario 1: Sequential Operations ---");
for (int i = 1; i <= 3; i++)
{
    logger.LogInformation("Sequential iteration {Iteration}", i);
    Console.WriteLine($"Class1 length: {c1.GetLengthOfInjectedProperty()}");
    Console.WriteLine($"Class2 length: {c2.GetLengthOfInjectedProperty()}");
    await Task.Delay(500);
}

logger.LogInformation("--- Scenario 2: Parallel Operations ---");
var tasks = Enumerable.Range(1, 5).Select(async i =>
{
    logger.LogInformation("Parallel task {TaskId} starting", i);
    await Task.Delay(100 * i);
    var len = c1.GetLengthOfInjectedProperty();
    logger.LogInformation("Parallel task {TaskId} completed with length {Length}", i, len);
    return len;
});

var results = await Task.WhenAll(tasks);
logger.LogInformation("Parallel results: {Results}", string.Join(", ", results));

logger.LogInformation("========================================");
logger.LogInformation("Application completed. Check Uptrace for telemetry data.");
logger.LogInformation("Telemetry files written to: {Directory}", fileExporterOptions.Directory);

// Give time for telemetry to flush before app exits
Console.WriteLine("\nWaiting for telemetry to flush...");
await Task.Delay(5000);

Console.WriteLine($"\nTelemetry files for this run (ID: {fileExporterOptions.RunId}):");
Console.WriteLine($"Directory: {fileExporterOptions.Directory}");
if (Directory.Exists(fileExporterOptions.Directory))
{
    var runFiles = Directory.GetFiles(fileExporterOptions.Directory, $"*_{fileExporterOptions.RunId}*.json");
    foreach (var file in runFiles)
    {
        var info = new FileInfo(file);
        Console.WriteLine($"  - {info.Name} ({info.Length:N0} bytes)");
    }
    
    if (runFiles.Length == 0)
    {
        Console.WriteLine("  (no files created yet - telemetry may still be flushing)");
    }
}
else
{
    Console.WriteLine("  (directory not created yet)");
}



================================================================================
FILE: :\Users\kushal\source\repos\HelloDotnetTen\source\HelloDotnetTen\HelloDotnetTen.slnx
SIZE: 0.18 KB
MODIFIED: 12/05/2025 15:22:18
================================================================================

<Solution>
  <Project Path="HelloDotnetTen.ClassLibrary1/HelloDotnetTen.ClassLibrary1.csproj" />
  <Project Path="HelloDotnetTen.Console/HelloDotnetTen.Console.csproj" />
</Solution>



===============================================================================
EXPORT COMPLETED: 12/07/2025 11:08:52
Total Files Exported: 20
Output File: .\docs\llm\dump.txt
===============================================================================
